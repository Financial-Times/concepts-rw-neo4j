// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"github.com/jmcvetta/neoism"
)

// region    *************************** template.gotpl ***************************
func locationCypherReadQuery(uuid string) *neoism.CypherQuery {
	query := &neoism.CypherQuery{
		Statement: "MATCH (canonical:Thing {prefUUID:{uuid}})<-[:EQUIVALENT_TO]-(source:Thing)\nWITH\n  canonical,\n  source\n  ORDER BY\n    source.uuid\nWITH\n  canonical,\n  {\n    authority: source.authority,\n    authorityValue: source.authorityValue,\n    lastModifiedEpoch: source.lastModifiedEpoch,\n    prefLabel: source.prefLabel,\n    types: labels(source),\n    uuid: source.uuid\n  } as sources\nRETURN\n  canonical.aggregateHash as aggregateHash,\n  canonical.aliases as aliases,\n  canonical.prefLabel as prefLabel,\n  canonical.prefUUID as prefUUID,\n  labels(canonical) as types,\n  canonical.iso31661 as iso31661,\n  collect(sources) as sourceRepresentations",
		Parameters: map[string]interface{}{
			"uuid": uuid,
		},
	}

	return query
}
func organisationCypherReadQuery(uuid string) *neoism.CypherQuery {
	query := &neoism.CypherQuery{
		Statement: "MATCH (canonical:Thing {prefUUID:{uuid}})<-[:EQUIVALENT_TO]-(source:Thing) \nOPTIONAL MATCH (source)-[:SUB_ORGANISATION_OF]->(parentOrg:Thing)\nOPTIONAL MATCH (source)-[:COUNTRY_OF_OPERATIONS]->(coo:Thing)\nOPTIONAL MATCH (source)-[:COUNTRY_OF_RISK]->(cor:Thing)\nOPTIONAL MATCH (source)-[:COUNTRY_OF_INCORPORATION]->(coi:Thing)\nOPTIONAL MATCH (source)-[hasICRel:HAS_INDUSTRY_CLASSIFICATION]->(naics:NAICSIndustryClassification)\nWITH\n  canonical,\n  parentOrg,\n  coo,\n  cor,\n  coi,\n  collect(DISTINCT {UUID: naics.uuid, Rank: hasICRel.rank}) as naicsIndustryClassifications,\n  source\n  ORDER BY\n    source.uuid\nWITH\n  canonical,\n  {\n    authority: source.authority,\n    authorityValue: source.authorityValue,\n    lastModifiedEpoch: source.lastModifiedEpoch,\n    prefLabel: source.prefLabel,\n    types: labels(source),\n    uuid: source.uuid,\n    parentOrganisation: parentOrg.uuid,\n    countryOfIncorporationUUID: coi.uuid,\n    countryOfOperationsUUID: coo.uuid,\n    countryOfRiskUUID: cor.uuid,\n    naicsIndustryClassifications: naicsIndustryClassifications\n  } as sources\nRETURN \n  canonical.aggregateHash as aggregateHash,\n  canonical.aliases as aliases,\n  canonical.prefLabel as prefLabel,\n  canonical.emailAddress as emailAddress,\n  canonical.prefUUID as prefUUID,\n  canonical.properName as properName,\n  canonical.shortName as shortName,\n  canonical.tradeNames as tradeNames,\n  canonical.formerNames as formerNames,\n  canonical.postalCode as postalCode,\n  canonical.yearFounded as yearFounded,\n  canonical.leiCode as leiCode,\n  canonical.countryCode as countryCode,\n  canonical.countryOfIncorporation as countryOfIncorporation,\n  canonical.countryOfOperations as countryOfOperations,\n  canonical.countryOfRisk as countryOfRisk,\n  labels(canonical) as types,\n  collect(sources) as sourceRepresentations",
		Parameters: map[string]interface{}{
			"uuid": uuid,
		},
	}

	return query
}

func CypherReadQuery(uuid string, conceptType string) *neoism.CypherQuery {
	switch conceptType {
	case "locations":
		return locationCypherReadQuery(uuid)
	case "organisations":
		return organisationCypherReadQuery(uuid)
	default:
		return nil
	}
}

// endregion *************************** template.gotpl ***************************
