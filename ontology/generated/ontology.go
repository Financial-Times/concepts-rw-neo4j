// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"encoding/json"

	"github.com/jmcvetta/neoism"
)

// region    *************************** template.gotpl ***************************

func locationCypherReadQuery(uuid string) *neoism.CypherQuery {
	query := &neoism.CypherQuery{
		Statement: `
                    MATCH (canonical:Thing {prefUUID:{uuid}})<-[:EQUIVALENT_TO]-(source:Thing)
                    WITH
                        canonical,
                        source
                        ORDER BY
                            source.uuid
                    WITH
                        canonical,
                        {
                            authority: source.authority,
                            authorityValue: source.authorityValue,
                            prefLabel: source.prefLabel,
                            types: labels(source),
                            uuid: source.uuid,
                            lastModifiedEpoch: source.lastModifiedEpoch
                        } as sources 
                        RETURN 
                        canonical.prefUUID as prefUUID,
                        canonical.aggregateHash as aggregateHash,
                        canonical.prefLabel as prefLabel,
                        canonical.aliases as aliases,
                        canonical.iso31661 as iso31661,
                        labels(canonical) as types,
                        collect(sources) as sourceRepresentations`,
		Parameters: map[string]interface{}{
			"uuid": uuid,
		},
	}

	return query
}

func locationProps(concept interface{}, id string, isSource bool) map[string]interface{} {
	var props map[string]interface{}
	tmp, _ := json.Marshal(concept)
	json.Unmarshal(tmp, &props)

	objFields := map[string]bool{
		"prefLabel": true,
		"aliases":   true,
		"iso31661":  true,
	}

	if isSource {
		objFields["authority"] = true
		objFields["authorityValue"] = true
	}

	for k := range props {
		if !objFields[k] {
			delete(props, k)
		}
	}

	if isSource {
		props["uuid"] = id
	} else {
		props["prefUUID"] = id
	}

	return props
}

func mapToLocation(concordedConcept interface{}) interface{} {
	var model = Location{}
	tmp, _ := json.Marshal(concordedConcept)
	json.Unmarshal(tmp, &model)

	return model
}
func organisationCypherReadQuery(uuid string) *neoism.CypherQuery {
	query := &neoism.CypherQuery{
		Statement: `
                    MATCH (canonical:Thing {prefUUID:{uuid}})<-[:EQUIVALENT_TO]-(source:Thing)
                    OPTIONAL MATCH (source)-[hasFocusUUIDsRel:HAS_FOCUS]->(hasFocusUUIDsNode:Thing)
                    OPTIONAL MATCH (source)-[naicsIndustryClassificationsRel:HAS_INDUSTRY_CLASSIFICATION]->(naicsIndustryClassificationsNode:NAICSIndustryClassification)
                    OPTIONAL MATCH (source)-[parentOrganisationRel:SUB_ORGANISATION_OF]->(parentOrganisationNode:Thing)
                    OPTIONAL MATCH (source)-[countryOfIncorporationUUIDRel:COUNTRY_OF_INCORPORATION]->(countryOfIncorporationUUIDNode:Thing)
                    OPTIONAL MATCH (source)-[countryOfOperationsUUIDRel:COUNTRY_OF_OPERATIONS]->(countryOfOperationsUUIDNode:Thing)
                    OPTIONAL MATCH (source)-[countryOfRiskUUIDRel:COUNTRY_OF_RISK]->(countryOfRiskUUIDNode:Thing)
                    WITH
                        canonical,
                                    collect(DISTINCT hasFocusUUIDsNode.uuid) as hasFocusUUIDs,
                                    collect(DISTINCT {Rank: naicsIndustryClassificationsRel.rank,UUID: naicsIndustryClassificationsNode.uuid}) as naicsIndustryClassifications,
                                    parentOrganisationNode,
                                    countryOfIncorporationUUIDNode,
                                    countryOfOperationsUUIDNode,
                                    countryOfRiskUUIDNode,
                        source
                        ORDER BY
                            source.uuid
                    WITH
                        canonical,
                        {
                            authority: source.authority,
                            authorityValue: source.authorityValue,
                            prefLabel: source.prefLabel,
                            types: labels(source),
                            uuid: source.uuid,
                            hasFocusUUIDs: hasFocusUUIDs,
                            naicsIndustryClassifications: naicsIndustryClassifications,
                            parentOrganisation: parentOrganisationNode.uuid,
                            countryOfIncorporationUUID: countryOfIncorporationUUIDNode.uuid,
                            countryOfOperationsUUID: countryOfOperationsUUIDNode.uuid,
                            countryOfRiskUUID: countryOfRiskUUIDNode.uuid,
                            lastModifiedEpoch: source.lastModifiedEpoch
                        } as sources 
                        RETURN 
                        canonical.prefUUID as prefUUID,
                        canonical.aggregateHash as aggregateHash,
                        canonical.prefLabel as prefLabel,
                        canonical.aliases as aliases,
                        canonical.emailAddress as emailAddress,
                        canonical.scopeNote as scopeNote,
                        canonical.properName as properName,
                        canonical.shortName as shortName,
                        canonical.tradeNames as tradeNames,
                        canonical.formerNames as formerNames,
                        canonical.countryCode as countryCode,
                        canonical.countryOfIncorporation as countryOfIncorporation,
                        canonical.countryOfOperations as countryOfOperations,
                        canonical.countryOfRisk as countryOfRisk,
                        canonical.postalCode as postalCode,
                        canonical.yearFounded as yearFounded,
                        canonical.leiCode as leiCode,
                        labels(canonical) as types,
                        collect(sources) as sourceRepresentations`,
		Parameters: map[string]interface{}{
			"uuid": uuid,
		},
	}

	return query
}

func organisationProps(concept interface{}, id string, isSource bool) map[string]interface{} {
	var props map[string]interface{}
	tmp, _ := json.Marshal(concept)
	json.Unmarshal(tmp, &props)

	objFields := map[string]bool{
		"prefLabel":              true,
		"aliases":                true,
		"emailAddress":           true,
		"scopeNote":              true,
		"properName":             true,
		"shortName":              true,
		"tradeNames":             true,
		"formerNames":            true,
		"countryCode":            true,
		"countryOfIncorporation": true,
		"countryOfOperations":    true,
		"countryOfRisk":          true,
		"postalCode":             true,
		"yearFounded":            true,
		"leiCode":                true,
	}

	if isSource {
		objFields["authority"] = true
		objFields["authorityValue"] = true
	}

	for k := range props {
		if !objFields[k] {
			delete(props, k)
		}
	}

	if isSource {
		props["uuid"] = id
	} else {
		props["prefUUID"] = id
	}

	return props
}

func mapToOrganisation(concordedConcept interface{}) interface{} {
	var model = Organisation{}
	tmp, _ := json.Marshal(concordedConcept)
	json.Unmarshal(tmp, &model)

	return model
}

func CypherReadQuery(uuid string, conceptType string) *neoism.CypherQuery {
	switch conceptType {
	case "locations":
		return locationCypherReadQuery(uuid)
	case "organisations":
		return organisationCypherReadQuery(uuid)
	default:
		return nil
	}
}

func Props(conceptType string, concept interface{}, id string, isSource bool) map[string]interface{} {
	switch conceptType {
	case "locations":
		return locationProps(concept, id, isSource)
	case "organisations":
		return organisationProps(concept, id, isSource)
	default:
		return map[string]interface{}{}
	}
}

func IsKnownType(conceptType string) bool {
	knownTypes := map[string]bool{
		"locations":     true,
		"organisations": true,
	}

	return knownTypes[conceptType]
}

func MapToKnownType(conceptType string, concordedConcept interface{}) interface{} {
	switch conceptType {
	case "locations":
		return mapToLocation(concordedConcept)
	case "organisations":
		return mapToOrganisation(concordedConcept)
	default:
		return concordedConcept
	}
}

// endregion *************************** template.gotpl ***************************
